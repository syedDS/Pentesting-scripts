#!/usr/bin/python3
#1.-f for user to provide a file with list of IP addresses/domains   OK
#2.-p is being extended to range of port using '-'   OK
# 3. select the type of port --pt --pu    OK
# 4. description of the port assciated with port number adn protocol   use of subprocess  and regex of open ports re.findall(func)  but now associate the description  dict(port:description)  OK
#5.use a -o parameter where the user will include a file-name (e.g. -o outputscan)   OK
# use argparse in place of optparse
# run in the cmd: python3 mypyproject.py -f list-IP-address.txt -p 20,21,23,80,135-139,386,443 --pt 1000-2000 --pu 22,53 -o outscan.txt

import optparse
from socket import *
from threading import *
import time,sys
import logging

def connScan(tgtHost, tgtPort,proType,resScan):

    logger = logging.getLogger(__name__)
     # adding a the port:description pair in dictionary
    portdesc = dict({20:"FTP is one of the most commonly used file transfer protocols on the Internet and within private networks.",21:"An FTP server can easily be set up with little networking knowledge and provides the ability to easily relocate files from one system to another."
    ,22:"SSH is the primary method used to manage network devices securely at the command level.",23:"Telnet is the primary method used to manage network devices at the command level"
    ,25:"SMTP is used for two primary functions, it is used to transfer mail (email) from source to destination between mail servers",53:"The DNS is used widely on the public internet and on private networks to translate domain names into IP addresses",
    67:"DHCP is used on networks that do not use static IP address assignment",68:"DHCP is used on networks that do not use static IP address assignment",69:"TFTP offers a method of file transfer without the session establishment requirements that FTP uses",
    80:"HTTP is one of the most commonly used protocols on most networks.",110:"POP version 3 is one of the two main protocols used to retrieve mail from a server.",123:"One of the most overlooked protocols is NTP. NTP is used to synchronize the devices on the Internet.",
    137:"NetBIOS itself is not a protocol but is typically used in combination with IP with the NetBIOS over TCP/IP",138:"NetBIOS itself is not a protocol but is typically used in combination with IP with the NetBIOS over TCP/IP",
    139:"NetBIOS itself is not a protocol but is typically used in combination with IP with the NetBIOS over TCP/IP ",143:"IMAP version3 is the second of the main protocols used to retrieve mail from a server.",
    161:"SNMP is used by network administrators as a method of network management.",162:"SNMP is used by network administrators as a method of network management." , 179:"BGP version 4 is widely used on the public internet and by Internet Service Providers",
    389:"LDAP provides a mechanism of accessing and maintaining distributed directory information. ",443:"HTTPS is used in conjunction with HTTP to provide the same services but doing it using a secure connection which is provided by either SSL or TLS.",
    636:"Just like HTTPS, LDAPS provides the same function as LDAP but over a secure connection which is provided by either SSL or TLS.",989:"FTP over TLS/SSL uses the FTP protocol which is then secured using either SSL or TLS.","990":"FTP over TLS/SSL uses the FTP protocol which is then secured using either SSL or TLS."})
    #the type of protocol stored in pname for formatting
    if proType == 'tcp' :
         pname=SOCK_STREAM
    else:
         pname=SOCK_DGRAM
    try:
        connSkt = socket(AF_INET, pname)  # using Ipv4 -AF_IFNET and SOCK_STREAM for tcp just change it to SOCK_DGRAM where protype wil hold the protcol type id
        result = connSkt.connect_ex((tgtHost,tgtPort))

        if result == 0:
            connSkt.connect((tgtHost, tgtPort))
            # adding description to the port and protocol
            print ('\033[0:32;1m'"[+] {0}/{1} is open port has protocol description :--{2} " .format( tgtPort, proType,portdesc.get(int(tgtPort))))
            O='\033[0:32;1m'"[+] {0}/{1} open" .format( tgtPort, proType)
            resScan.write(O)                                    # writing the output

        else:

            print ('\033[0:31;1m'"[-] {0}/ {1} closed".format( tgtPort, proType))
            print ('\033[m')
            L = '\033[0:31;1m'"[-] {0}/ {1} closed".format( tgtPort, proType)
            resScan.write(L)
    #handling various exceptions
    except BlockingIOError:
        return False  # socket is open and reading from it would block
    except ConnectionResetError:
        return True  # socket was closed for some other reason
    except Exception as e:
        logger.exception("unexpected exception when checking if a socket is closed")
        return False

    finally:
        connSkt.close()

def portScan(tgtHost, tgtPorts,proType,resScan):

    try:
        tgtIP = gethostbyname(tgtHost)
    except:
        print ("[-] Cannot resolve '%s': Unknown host" %tgtHost)
        I = "[-] Cannot resolve '%s': Unknown host" %tgtHost
        resScan.write(I)
        return

    try:
        tgtName = gethostbyaddr(tgtIP)
        #print(tgtIP,tgtName)
        print ("\n[+] Scan Results for:{0}/{1} " .format(proType,tgtName[0]))
        L="\n[+] Scan Results for:{0}/{1} " .format(proType,tgtName[0])
        resScan.write(L)
   #accepting keyboard interrupt
    except KeyboardInterrupt:
       print("You pressed Ctrl+C")
       sys.exit()
    except:
        print ('\n[+] Scan Results for:{0}/{1} ' .format(proType,tgtIP))
        O= '\n[+] Scan Results for:{0}/{1} ' .format(proType,tgtIP)
        resScan.write(O)


    setdefaulttimeout(1)
    for tgtPort in tgtPorts:
        t = Thread(target=connScan,args=(tgtHost,int(tgtPort),proType,resScan))   # add the 3rd argument for the passing socket type argument
        t.start()

def calc_time(t1,t2,resScan):
     #difference
         time_spent = t2 - t1
     #print out the final information
         print("\n[*] Scanning completed at: ", time.strftime("%I:%M:%S %p"))
     #time spent calcultion
         if time_spent <= 60:
            time_spent = str(round(time_spent, 2))
            print("[*] Scanning Duration: ", time_spent, " seconds")
            O="[*] Scanning Duration: "+ time_spent+ " seconds"
            resScan.write(O)
         else:
            time_spent = round((time_spent / 60), 2)
            print("[*] Scanning Duration: ", time_spent, " minutes")
            L= "[*] Scanning Duration: "+ time_spent+ " minutes"
            resScan.write(L)

def main():

    t1 = time.time()
    #intialize to TCP connection
    #proType= SOCK_STREAM
    proType='tcp'
    parser = optparse.OptionParser('usage %prog' + '-f <target host-name/IP-Address>')
    parser.add_option('-f', dest='ipFile', type='string', help='reading target host a form of file with list of addresses/domain-names(one host-name or ip address per line)',metavar="FILE")
    parser.add_option('-p', dest='tgtPort', type='string',help='specify target port[s] separated by comma/hyphen')
    #using -- as long option is need  and -pt gives optparse error
    parser.add_option('--pt',dest='addTPort',type='string',help='specify target port[s] separated by hypen')
    parser.add_option('--pu',dest='addUPort',type='string',help='specify target port[s] separated by comma')
    parser.add_option('-o','--outFile',dest='tgtfilename',type='string',help="write scan report to FILE", metavar="FILE")
    #initalizing timer

    (options, args) = parser.parse_args()
    #print(str(options.addUPort))
    inputFile= str(options.ipFile)
    #dont use readlines as it leave /n so i have to split and take the newline out
    hostList=open(inputFile,'r+').read().split('\n')
    hostL=hostList[:-1]

     # writing the scan on to file
    outScan= str(options.tgtfilename)
    resScan=open("outScan.txt",'w+')

# for --pt and --pu functionalities
    for tgtHost in hostL:
    # print("host read=%s" % tgtHost)
      if '-' in str(options.tgtPort):
           tgtPorts = options.tgtPort.split('-')
           tgtPorts = range(int(tgtPorts[0]),int(tgtPorts[1]))
           proType='tcp'

      else:
          tgtPorts = str(options.tgtPort).split(',')
          proType='tcp'
      portScan(tgtHost, tgtPorts,proType,resScan)
   # for reading the delimiter for tcp
      if '-' in str(options.addTPort):
        tgtPorts = options.addTPort.split('-')
        tgtPorts = range(int(tgtPorts[0]),int(tgtPorts[1]))
        proType= 'tcp'
      portScan(tgtHost, tgtPorts,proType,resScan)
    # for reading the , separator in udp
      if ',' in str(options.addUPort):
        tgtPorts = options.addUPort.split(',')
        #proType=SOCK_DGRAM
        proType='udp'
      if (tgtHost == None) | (tgtPorts[0] == None):
        print (parser.usage)
        exit(0)
      portScan(tgtHost, tgtPorts,proType,resScan)

  #get the time that the system finished checking the ports
    t2 = time.time()
    calc_time(t1,t2,resScan)


if __name__ == '__main__':
    main()
